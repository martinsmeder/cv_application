==================== Principle 1: Group related state =====================
If you always update two or more state variables at the same time, 
consider merging them into a single state variable.

Exercise: Simple Counter
Task to perform: Create a simple counter component. When you click a "+" 
button, the counter should increment, and when you click a "-" button, it 
should decrement.

import { useState } from 'react';

export default function App() {
  const [count, setCount] = useState(0);

  function handleClick(operator) {
    if (operator === '+') setCount(count + 1);
    else setCount(count - 1);
  }

  return (
    <>
      <h1>{count}</h1>
      <button onClick={() => handleClick('+')}>+</button>
      <button onClick={() => handleClick('-')}>-</button>
    </>
  );
}

=================== Principle 2: Avoid contradictions in state ================
When the state is structured in a way that several pieces of state may 
contradict and “disagree” with each other, you leave room for mistakes. Try 
to avoid this.

Exercise: Light Switch
Create a light switch component. The component should have a button that 
toggles the state of the light between "ON" and "OFF." The button text 
should change to reflect the current state.
Use props to pass the initial state (either "ON" or "OFF") to the component.
Ensure that clicking the button toggles the state between "ON" and "OFF" 
without contradictions.

function ToggleButton({ initialValue }) {
  const [isOn, setIsOn] = useState(initialValue);

  function toggleIsOn() {
    setIsOn(!isOn);
  }

  return <button onClick={toggleIsOn}>{isOn ? 'ON' : 'OFF'}</button>;
}

export default function App() {
  return (
    <>
      <ToggleButton initialValue={false} />
    </>
  );
}

==================== Principle 3: Avoid redundant state =====================
If you can calculate some information from the component’s props or its 
existing state variables during rendering, you should not put that information 
into that component’s state.

Exercise: User Greeting
Create a user greeting component that displays a personalized greeting 
message. The component should accept a prop called userName representing 
the user's name. Instead of storing the user's name in component state, 
use the userName prop directly to generate the greeting message.
The component should render a message like "Hello, [userName]!" where 
[userName] is replaced with the value of the userName prop. Avoid creating 
a separate state variable for the user's name; directly use the userName 
prop in rendering the message.

function Greeting({ userName }) {
  return <h1>Hello, {userName}!</h1>;
}

export default function App() {
  return (
    <>
      <Greeting userName={'dude'} />
    </>
  );
}

==================== Principle 4: Avoid duplication in state ==================
When the same data is duplicated between multiple state variables, or within 
nested objects, it is difficult to keep them in sync. Reduce duplication when 
you can.

Exercise: Product Quantity
Create a product quantity component that displays the quantity of products
and allows the user to increase or decrease it. Instead of duplicating the
quantity value between component state and props, use props to pass the
initial quantity value to the component, and manage the quantity using only
the state. Make sure to manage the quantity by using a single state variable.


const productArray = [
  { name: 'first product', quantity: 0 },
  { name: 'second product', quantity: 3 },
];

function RenderProducts({ initialProducts }) {
  const [products, setProductList] = useState(initialProducts);

  function handlePlusClick(index) {
    const updatedProducts = [...products]; // Create copy
    updatedProducts[index].quantity += 1; // Modify quantity
    setProductList(updatedProducts); // Update state variable
  }

  function handleMinusClick(index) {
    const updatedProducts = [...products]; // Create copy
    updatedProducts[index].quantity -= 1; // Modify quantity
    setProductList(updatedProducts); // Update state variable
  }

  return (
    <ul>
      {products.map((product, index) => (
        <li key={index}>
          {product.name} : {product.quantity}
          <button onClick={() => handlePlusClick(index)}>+</button>
          <button onClick={() => handleMinusClick(index)}>-</button>
        </li>
      ))}
    </ul>
  );
}

export default function App() {
  return (
    <>
      <RenderProducts initialProducts={productArray} />
    </>
  );
}